//=====================================================================================================================
// Общее название реализованной в файле функциональности - если есть
//---------------------------------------------------------------------------------------------------------------------
// Список ответственных, имена, адреса, явки, пароли - чтобы знать к кому обращаться при возникновении вопросов.
// Описание содержимого. Должно кратно отражать суть, в частности, что объединяет реализованные в файле функции.
// В заголовке не надо перечислять, что делает каждая функция в файле.
// Если в заголовке нет разумной необходимости - он вполне может отсутствовать.
// пример оформления заголовка  - Lib_cr_timer.cpp
//=====================================================================================================================

// заголовочные файлы подключать строго по необходимости! лишних не надо, это создает ненужные зависимости и тормозит компиляцию.
// не надо копировать пачки хедеров из файла в файл
#include "data_global.h"
#include "cr_timer.h"

// TAB - не используем! только пробелы. 
// ширина табуляции - 4 пробела. 
// максимальную длину строки берем 120 символов. 
// кодировка - UTF-8 без сигнатуры

// Элементы декора - горизонтальные отсечки предлагается делать по максимальной ширине строки - 120
// чтобы наглядно было видно границы строк кода, за которые не надо выходить
// Двойные линии обрамляют функции, одинарные разделяют смысловые блоки внутри функции
//=====================================================================================================================
//---------------------------------------------------------------------------------------------------------------------
// элементы декора считаем делом вкуса и уместности в зависимости от размера функций, структуры кода и т.д.

static int staticVar; // статические объекты не разбрасываем, всё размещаем в начале файла. 
// всё, что не используется извне - делаем статик. чтобы сразу было видна локальность для данного файла. 

//=====================================================================================================================
void Viscosity(const int FillMatrix, // строку переносим, если аргументов слишком много и выходит за 120
               double value; // или если надо прокомментировать отдельные аргументы
               const int MeanFlow){  // краткое описание функции. скобку не отрываем!
// если надо - более подробное описание функции, входных и выходных параметров. 
// FillMatrix - такой-то параметр, MeanFlow - сякой-то параметр. 
// Описание писать после строки с объявлением функции, чтобы вижлы могли выдавать его как подсказку
// Все аргументы, которые являются входными данными и не меняются в функции, описывать как const! 
//=====================================================================================================================

//  переменные описываем желательно в порядке размера типа. сначала даблы потом инты, чтобы не портить выравнивание. 
//  это имеет значение особенно в структурах нижнего уровня. 
//  исключение: если, например, какие-то инты и даблы логически связаны и по этому сгруппированы, не растаскиваем их. 

    double var1; // каждое описание комментить. короткий коммент - в той же строке, длинный - перед.
    double var2; // в начале строчки тип обязательно. не надо переносить после запятой переменную на новую строку. 
    int obviousVar1, obviousVar2; // если переменные не нуждаются в отдельном комменте - группировать в строчку. 
    
//  условия
    if(condition){ // открывающую скобку структурного блока не переносим
        int x=0; // переменные, локальные для стуктурного блока описываем строго в нем. 
        function1(x);
        function2();
    }
    else{ // если коммент к структурному блоку краткий - писать в той же строке с открывающей скобкой. 
        int x=0; // если переменная по сути локальна для блока, но встречается в разных блоках - не ленимся, описываем.
        function3(x); // короткий коммент к вызову - в ту же строку
        
//      длинный коммент - перед вызовом. 
//      при этом текст в комментах выравниваем! 
        //или выравниваем весь комментарий - дело вкуса
        function3();
    }

//  если действие коротко и {} можно не использовать, то делать oneлайнер! не переносить на след. строчку ибо опасно. 
//  если в одну строчку длинно, то извольте открыть структурный блок. 
    if(condition) function3();

//  если переменная цикла имеет локальный смысл - описывать прям в заголовке цикла.  
//  в заголовке цикла пробелы после ;    
    for(int jt=JT[0]; jt<JT[1]; jt++){ // если коммент к циклу короткий - в ту же строку. 
        const double c = 1.0; // всё, что не меняется при использовании, описывать как константы в явном виде. 
        // не использовать короткую форму записи числа с плавающей точкой вида "1."

        function1(с);
        function2();
    }

//  если цикл без структурного блока - то только в одну строку!
    for(int jt=JT[0]; jt<JT[1]; jt++) function1();
  
    switch(Iter){ // кейсы ровняем по свичу
    case 1: JT=TopoLims[OMP_TRN]; break; // короткое действие можно в одну строку
    case 2: 
        JT=TopoLims[OMP_NTR+OMP_TRN];
        JT=TopoLims[OMP_NTR+OMP_TRN];
        break; // если кейс длинный, то брейк обязательно с новой строки, чтоб был хорошо заметен
    case 3: JT=TopoLims[2*OMP_NTR]; break;
    default:  function2(); // всегда бы дефолт чтоб был
    }

//  прагмы выравниваем     
    #pragma omp parallel default(shared)
    {
        if(Solver2D) Visc2D(FillMatrix, MeanFlow);
        if(Solver3D) Visc3D(FillMatrix, MeanFlow);   
    }

//  сложные выражения ровняем пробелами из эстетических соображений. ровные колонки - это прекрасно. 
//  пробельчики вокруг операций с нижним приоритетом - сложения вычитания равно всякие. умножения лучше без пробельчиков
    CE[ii][Var_U] -= ait*(dbxp[k]*Sxx + dbyp[k]*Sxy);
    CE[ii][Var_V] -= ait*(dbxp[k]*Sxy + dbyp[k]*Syy);
    CE[ii][Var_P] -= ait*(dbxp[k]*Fx  + dbyp[k]*Fy);

//  длинные выражения выравниванием при разбиении на неск строк следующим образом:
    if(j==4) crash("SmoothGlobal error: node %i has more than 4 incident quads: %i,%i,%i,%i,%i!\n",
                   is, NADJ[is][0], NADJ[is][1], NADJ[is][2], NADJ[is][3], it); //по открывающей скобке               
                    
    double conv = sqrt(Du_Dx*Du_Dx + Du_Dy*Du_Dy + Du_Dz*Du_Dz +  //ровняем по открывающей скобке
                       Dv_Dx*Dv_Dx + Dv_Dy*Dv_Dy + Dv_Dz*Dv_Dz +
                       Dw_Dx*Dw_Dx + Dw_Dy*Dw_Dy + Dw_Dz*Dw_Dz);  

    h[0] = (m[0]*ba[0]+m[1]*ba[1]+m[2]*ba[2]+(m[1]-a[1])*ba[1]+a[0]*ba[1]*ba[1]/ba[0])/ //ровняем по выражению
           (ba[0]+ba[1]*ba[1]/ba[0]+ba[2]*ba[2]/ba[0]);  
//         в длинных строках можно и не лепить пробелы к низкоприотитетным операциям.
}

// если функция не используется вне файла - декларить static, чтобы локальность была очевидна
static double CalcP(const double v){ // коммент
    return 0.0;
}

//---------------------------------------------------------------------------------------------------------------------
// методы класса tTemp - не перемешиваем методы одного класса с другими функциями и чужими методами без необходимости
//---------------------------------------------------------------------------------------------------------------------  

void tTemo::func1(){ // комментарий
    printf(" hello world 1 \n");
}

void tTemo::func2(){ // комментарий
    printf(" hello world 2 \n");
}
